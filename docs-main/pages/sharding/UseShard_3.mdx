---
title: Deploying Contracts
---

## Deploying Contracts with Stylus CLI

1. **Install Rust Toolchain**: Ensure you have Rust installed by following the instructions on the [Rust Lang installation page](https://www.rust-lang.org/tools/install). Confirm that `rustup`, `rustc`, and `cargo` are accessible from your command line.

2. **Set Up VS Code**: Use VS Code for your development environment, leveraging its strong support for Rust. Install helpful extensions like `rust-analyzer`, `Error Lens`, `Even Better TOML`, and `crates` to enhance your development workflow.

3. **Acquire Testnet ETH**: You'll need testnet ETH (Sepolia ETH) for deploying your Rust contracts. Obtain it from [Bware Labs faucet](https://bwarelabs.com/faucets/arbitrum-stylus-testnet) or other sources mentioned.

4. **Create Developer Wallet**: Use a fresh MetaMask account labeled as a dev wallet or "Stylus". Follow MetaMask's guidelines to obtain the private key for this account, ensuring it contains only testnet assets.

5. **Install Stylus CLI**: Once Rust is installed, install the Stylus CLI tool (`cargo-stylus`) with the following command:

   ```sh
   cargo install --force cargo-stylus cargo-stylus-check
   ```

   Ensure `wasm32-unknown-unknown` is added as a Rust target:

   ```sh
   rustup target add wasm32-unknown-unknown
   ```

6. **Develop and Validate Contracts**: Start a new Stylus project using:

   ```sh
   cargo stylus new <YOUR_PROJECT_NAME>
   ```

   Alternatively, for a minimal setup, use:

   ```sh
   cargo stylus new --minimal <YOUR_PROJECT_NAME>
   ```

7. **Check Project Validity**: Validate your project's readiness for deployment with:

   ```sh
   cd <YOUR_PROJECT_NAME>
   cargo stylus check
   ```

   Adjust parameters as needed to ensure compatibility with the JSON-RPC endpoint.

8. **Deploy Your Contract**: Estimate gas requirements with:

   ```sh
   cd <YOUR_PROJECT_NAME>
   cargo stylus deploy --private-key-path=<PRIVKEY_FILE_PATH> --estimate-gas-only
   ```

   Then deploy with:

   ```sh
   cd <YOUR_PROJECT_NAME>
   cargo stylus deploy --private-key-path=<PRIVKEY_FILE_PATH>
   ```

   Follow the prompts to finalize deployment and activate your contract on the designated address.

9. **Deploy Non-Rust WASM Projects**: You can deploy projects written in non-Rust languages (like C) by specifying the WASM file directly:

   ```sh
   cd <YOUR_PROJECT_NAME>
   cargo stylus deploy --priv-key-path=<YOUR PRIV KEY FILE PATH> --wasm-file-path=add.wat
   ```

10. **Export Solidity ABIs**: For projects using the Stylus SDK, export Solidity ABIs easily with:
    ```sh
    cd <YOUR_PROJECT_NAME>
    cargo stylus export-abi
    ```
    This command simplifies integration with other Ethereum-based projects.

## Deploying Contracts with scripts

1. Complete steps 1-5 above to set up the required environment (Rust and Cargo).

2. **Clone the Repository**: First, clone the adventure-layer-scripts repository to your local machine:

   ```sh
   git clone https://github.com/DavidCoder88/adventure-layer-scripts.git
   ```

3. **Initialize the Environment**: Navigate to the `stylus-demos` directory and set up your environment:

   ```sh
   cd adventure-layer-scripts/stylus-demos
   cp ./scripts.env.example .env
   ```

4. **Deploy the Contract**: Use the provided script to deploy your contract:
   ```sh
   ./scripts/deploy.sh
   ```
5. **Export Solidity ABIs**: Get the contract ABI using the script provided:
   ```sh
   ./scripts/abi.sh
   ```

## Accessing the Shard Node:

To facilitate seamless interaction with Shard Node, The Adventure Layer uses URL routing. Suppose our node domain is rpc.adventure.dev. The nodes can be accessed through the following URLs:

- **Shard Node:**
  - URL: `http://rpc.adventure.dev/node1/shard`
  - Description: In the context of The Adventure Layer, `node1` serves as a placeholder for accessing specific nodes within the blockchain infrastructure. Depending on the context, replace `node1` with the actual node identifier, such as node2. This identifier helps direct requests to the shard node, enabling targeted interactions tailored to the node's specialized functionalities.
